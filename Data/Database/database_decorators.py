import os
import logging
from datetime import datetime
import subprocess

HOSTNAME = 'localhost'
DATABASE = 'First_test'
USERNAME = 'postgres'
PWD = 'Yann'
PORT_ID = 5432
BACKUP_DIR = r'C:\Users\yskon\Desktop\Desk_App\Data\Database\back_up'

# Configuration du logger
def setup_logger(log_file):
    log_directory = 'log'
    if not os.path.exists(log_directory):
        os.makedirs(log_directory)
    logging.basicConfig(level=logging.INFO,
                        format='%(asctime)s - %(levelname)s - %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S',
                        filename=os.path.join(log_directory, log_file),
                        filemode='a')

# Décorateur de log et de sauvegarde de base de données
def log_and_backup(func):
    def wrapper(*args, **kwargs):
        # Initialisation du logger
        setup_logger('log_file.log')

        try:
            # Enregistrement du timestamp de début d'exécution
            start_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            logging.info(f'Début de l\'exécution de la fonction {func.__name__} à {start_time}')

            # Sauvegarde de la base de données principale
            backup_file = backup_database()

            # Restauration de la base de données de sauvegarde dans la cible
            restore_database(backup_file)

            # Appel de la fonction décorée
            result = func(*args, **kwargs)

            # Enregistrement du timestamp de fin d'exécution
            end_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            logging.info(f'Fin de l\'exécution de la fonction {func.__name__} à {end_time}')

            return result
        except Exception as e:
            # Enregistrement des erreurs dans les logs
            logging.error(f'Erreur lors de l\'exécution de la fonction {func.__name__}: {e}')
            raise e

    return wrapper



def backup_database():
    """
    Backup the entire database using pg_dump.
    """
    try:
        # Create the backup directory if it doesn't exist
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)

        # Generate backup file name based on current timestamp
        backup_file = os.path.join(BACKUP_DIR, f"backup_{datetime.now().strftime('%Y%m%d%H%M%S')}.backup")

        # Construct pg_dump command
        pg_dump_cmd = [
            'pg_dump',
            '-h', HOSTNAME,
            '-U', USERNAME,
            '-d', DATABASE,
            '-F', 'c',  # Custom format backup
            '-f', backup_file
        ]

        # Execute pg_dump command
        subprocess.run(pg_dump_cmd, check=True)

        logging.info(f"Database backup completed successfully. Backup file: {backup_file}")
        return backup_file
    except Exception as error:
        logging.error(f"Error backing up database: {error}")
        return None  # Return None if backup fails

def restore_database(backup_file):
    """
    Restore the backup file into the target database.
    """
    try:
        # Construct pg_restore command
        pg_restore_cmd = [
            'pg_restore',
            '-h', HOSTNAME,
            '-U', USERNAME,
            '-d', DATABASE,
            '--clean',  # Clean (drop) database objects before recreating them
            backup_file   # Path to the backup file generated by pg_dump
        ]

        # Execute pg_restore command
        subprocess.run(pg_restore_cmd, check=True)

        logging.info("Database restoration completed successfully.")
    except Exception as error:
        logging.error(f"Error restoring database: {error}")


